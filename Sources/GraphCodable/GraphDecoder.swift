//	MIT License
//
//	Copyright (c) 2021-2023 Antonino Ficarra
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.

import Foundation

///	A struct that specifies the name of the encoded
/// class to match the type to create
///
/// Used by `GraphDecoder` `setType(...)` function.
public enum ClassName : Hashable {
	///	The `mangledName` string
	///
	/// You can specify the class `mangledName` generated
	/// by `_mangledTypeName( type )` during encoding.
	///
	/// `.mangledName` is preferred option
	case mangledName( _:String )
	///	The `qualifiedName` string
	///
	/// You can specify the class `qualifiedName` generated
	/// by `_typeName( type, qualified:true )` during encoding.
	case qualifiedName( _:String )
}

public typealias ClassNameMap 		= [ClassName : GDecodable.Type ]

/// Cointains info of encodeded classes that cannot be decoded.
public struct UndecodableClass {
	///	the class `qualifiedName` generated by `_typeName( type, qualified:true )` during encoding.
	public let	qualifiedName:			String
	///	the class `mangledName` generated by `_mangledTypeName( type )` during encoding.
	public let	mangledName:			String
	///	the class encoded version
	public let	encodedClassVersion:	UInt32
	
	fileprivate init( _ qualifiedName: String, _ mangledName: String, _ encodedClassVersion: UInt32) {
		self.qualifiedName = qualifiedName
		self.mangledName = mangledName
		self.encodedClassVersion = encodedClassVersion
	}
}

///	An object that decodes instances of a **GDecodable** type
///	from a data buffer that uses **GraphCodable** format.
public final class GraphDecoder {
	private let decoder : GDecoderImpl

	/// GraphDecoder init method
	///
	/// - If `archiveIdentifier` is not `nil`, it must match the encoded one otherwise the
	/// `BinaryIOError.archiveIdentifierDontMatch` exception is thrown.
	/// - If `archiveIdentifier` is `nil`, any encoded archiveIdentifier match
	///
	/// - Parameter archiveIdentifier: a string identifier to match the encoded one
	/// - Note: By default, the identifier `defaultGraphCodableArchiveIdentifier` is used.
	public init( archiveIdentifier: String? = defaultGraphCodableArchiveIdentifier ) {
		self.decoder = GDecoderImpl( archiveIdentifier:archiveIdentifier )
	}
	
	///	get/set the userInfo dictionary
	public var userInfo : [String:Any] {
		get { decoder.userInfo }
		set { decoder.userInfo = newValue }
	}
	
	///	get the dictionary that maps the type to create
	///	when an encoded className is encountered
	public var classNameMap : ClassNameMap {
		decoder.classNameMap
	}
	
	///	Set the type to create when an encoded className
	///	is encountered.
	///
	///	**The type can also be a value type.**
	///
	/// - Parameter type: the type to create.
	/// - Parameter className: a struct that specifies the name of the encoded
	/// class to match the type to create
	public func setType( _ type:GDecodable.Type, for className:ClassName ) {
		decoder.classNameMap[ className ] = type
	}
	
	///	Decode the root value from a native binary format buffer
	///
	/// Example:
	/// ```
	///	let root = try GraphDecoder().decode( RootType.self, from: data )
	/// ```
	///
	/// - Parameter type: the value type to decode.
	/// - Parameter data: the native binary format buffer.
	///	- Note: The root value must conform to the `GDecodable` protocol
	///	- Note: Only archives generated by `GraphEncoder` can be decoded
	public func decode<T,Q>( _ type: T.Type, from data: Q ) throws -> T
	where T:GDecodable, Q:DataProtocol {
		try decoder.decodeRoot( type, from: data)
	}

	///	Creates a human-readable string of the archived data
	///
	/// Example:
	/// ```
	///	let string = try GraphDecoder().dump( from: data )
	/// ```
	///
	/// - Parameter data: the archived data to decode.
	/// - Parameter options: a series of options to choose the information to be generated.
	/// - Returns: a human-readable string representation of the archive that would be generated.
	/// by the `encode(...)` function.
	public func dump<Q>( from data: Q, options: GraphDumpOptions = .readable ) throws -> String
	where Q:DataProtocol {
		try decoder.dumpRoot( from: data, options:options )
	}
	
	///	Get the archiveIdentifier encoded in the archived data
	///
	/// Example:
	/// ```
	///	let identifier = try GraphDecoder().encodedArchiveIdentifier( from: data )
	/// ```
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: the encoded archiveIdentifier.
	/// - Note: the encoded archiveIdentifier can be `nil`
	public func encodedArchiveIdentifier<Q>( from data: Q ) throws -> String?
	where Q:DataProtocol {
		try decoder.encodedArchiveIdentifier(from: data )
	}

	///	Returns an array of types that will potentially be instantiated
	///	after replacements from encoded classes  in the data byte buffer
	///
	///	As a result of the replacements, types may not be classes
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: the requested array of `GDecodable` types.
	public func decodableTypes<Q>( from data: Q ) throws -> [GDecodable.Type]
	where Q:DataProtocol {
		return try decoder.allClassData( from: data ).compactMap { $0.decodedType }
	}

	///	Returns all replaced classes encoded in the data byte buffer
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: the requested array of `GDecodable` types.
	public func replacedClasses<Q>( from data: Q ) throws -> [GDecodable.Type]
	where Q:DataProtocol {
		return try decoder.allClassData( from: data ).compactMap { $0.replacedClass }
	}

	///	Returns a `UndecodableClass` struct for every undecodable class in the data byte buffer
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: the requested array of `UndecodableClass` values.
	public func undecodableClasses<Q>( from data: Q )
	throws -> [UndecodableClass]
	where Q:DataProtocol {
		return try decoder.allClassData( from: data ).compactMap {
			$0.decodedType == nil ?
			UndecodableClass( $0.qualifiedName, $0.mangledName, $0.encodedClassVersion ) : nil
		}
	}
	
}


