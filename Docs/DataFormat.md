#  Data Format

GraphEncoder encode data in a private binary format. Having to preserve information about the types, GraphCodable creates larger data in bytes than those generated by Codable encoders. Despite this, the time required for encoding and decoding is generally comparable if not faster.

You can get a readable representation of the encoded data in a string with the `dump()` function.

## Readable output of the encoded data
Let's consider this example:
```swift
import Foundation
import GraphCodable

struct AStruct : Equatable, GCodable {
	var array	= [1,2,3]
	var dict	= ["4":4,"5":5]
	
	init() {}
	
	private enum Key : String {
		case array, dict
	}
	
	func encode(to encoder: GEncoder) throws {
		try encoder.encode( array, for: Key.array )
		try encoder.encode( dict, for: Key.dict )
	}
	
	init(from decoder: GDecoder) throws {
		array	= try decoder.decode(for: Key.array )
		dict	= try decoder.decode(for: Key.dict )
	}
}

class AClass : GCodable {
	var astruct	= AStruct()
	var aclass	: AClass?
	
	private enum Key : String {
		case astruct, aclass
	}
	
	init() {}
	
	func encode(to encoder: GEncoder) throws {
		try encoder.encode( astruct, for: Key.astruct )
		// note:
		try encoder.encodeConditional( aclass,  for: Key.aclass )
	}
	
	required init(from decoder: GDecoder) throws {
		astruct	= try decoder.decode(for: Key.astruct )
		aclass	= try decoder.decode(for: Key.aclass )
	}
}

let a = AClass()
let b = AClass()

//	we store a in b.aclass while a.aclass remains nil
b.aclass	= a

let	inRoot = [b, b, b, b, a]

print( try GraphEncoder().dump( inRoot ) )
```
The result:

```
== GRAPH =========================================================
- Struct
	- Obj_1000 MyGraphCodableApp.AClass
		+ "astruct": Struct
			+ "array": [1, 2, 3]
			+ "dict": ["5": 5, "4": 4]
		.
		+ "aclass": Ptr_1001?
	.
	- Ptr_1000
	- Ptr_1000
	- Ptr_1000
	- Obj_1001 MyGraphCodableApp.AClass
		+ "astruct": Struct
			+ "array": [1, 2, 3]
			+ "dict": ["4": 4, "5": 5]
		.
		+ "aclass": nil
	.
.
==================================================================
```
By default `dump()` prints only the **GRAPH** section of the data.

The **GRAPH** section contains the structured data, organized in:
- *Sequences*: a list of items preceded by the **-** symbol.
- *Dictionaries*: a list of items (in the form "key": value) preceded by the **+** symbol.

Both lists end when the symbol **.** is encountered.

The root is always the only item of the first sequence.

Rows by rows:
-	`STRUCT`, a value type, is the root.
-	It contains 5 elements corresponding to `[b, b, b, b, a]`:
	-	The first element `Obj_1000 MyGraphCodableApp.AClass` is a reference (`Obj`) type.
		GraphCodable assigns a unique numeric `Obj_number` to each object it encounters.
		This object in turn contains a structure corresponding to the key 'astruct' and an object corresponding to the key 'aclass'
		-	First, you see the complete definition of the struct, with its array and its dictionary. They contain native types.
			The list of all GCodable supported types of Swift Standard Library and Foundation is [here](/Docs/GraphCodableTypes.md).
		- 	Then you see: `"aclass": Ptr_1001?` This is because aclass has been conditionally archived.
			The encoder assigns it an attempt `Ptr_number?` and waits for it to be stored unconditionally if it happens.
	-	The second, third and fourth element of the array are pointers `Ptr_1000` to **b**, which has already been stored as `Obj_1000`.
		Therefore the encoder only stores the `Ptr_number`, which this time is certain (`Ptr_number` without question mark).
	-	The fifth element is `a` which was not archived previously and is therefore archived now.

*As an exercise*: see what happens when you delete `a` from the array.

*As an exercise*: try to see what happens by encoding `"aclass"` *not-conditionally*.

## Binary like output of the encoded data

GraphCodable employs some tricks to reduce the size of the data to be stored.
For example, types and keys are saved only once in special tables and are addressed to them through a unique ID.
By using the '.binaryLike' option you can see the data saved in a format that more closely resembles the binary format actually used.

`print( try GraphEncoder().dump( inRoot, options: .binaryLike ) )`

```
== HEADER ========================================================
Filetype = gcodable V0, U0 = "", U1 = 0, U2 = 0
== TYPEMAP =======================================================
Type100:	MyGraphCodableApp.AClass V0
== GRAPH =========================================================
- Struct
	- Obj_1000 Type100
		+ Key100: Struct
			+ Key101: [1, 2, 3]
			+ Key102: ["4": 4, "5": 5]
		.
		+ Key103: Ptr_1001?
	.
	- Ptr_1000
	- Ptr_1000
	- Ptr_1000
	- Obj_1001 Type100
		+ Key100: Struct
			+ Key101: [1, 2, 3]
			+ Key102: ["5": 5, "4": 4]
		.
		+ Key103: nil
	.
.
== KEYMAP ========================================================
Key100:	"astruct"
Key101:	"array"
Key102:	"dict"
Key103:	"aclass"
==================================================================
```

You can see:
- The **HEADER** section, with the file format name (gcodable), its global version, and some unused fields;
- The **TYPEMAP** section, in which an **TypeID** is associated with each class with its version;
- The **GRAPH** section, which uses typeIDs and keyIDs;
- The **TYPEMAP** section, in which an **KeyID** is associated with each key used in keyed coding;
