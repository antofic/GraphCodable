#  Data Format

GraphEncoder encode data in a private binary format. Having to preserve information about the types, GraphCodable creates larger data in bytes than those generated by Codable encoders. Despite this, the time required for encoding and decoding is generally comparable if not faster.

You can get a readable representation of the encoded data in a string with the `dump()` function.

## Readable output of the encoded data
Let's consider this example:
```swift
import Foundation
import GraphCodable

struct AStruct : Equatable, GCodable {
	var array	= [1,2,3]
	var value	= 1.56
	
	init() {}
	
	private enum Key : String {
		case array, value
	}
	
	func encode(to encoder: some GEncoder) throws {
		try encoder.encode( array, for: Key.array )
		try encoder.encode( value, for: Key.value )
	}
	
	init(from decoder: some GDecoder) throws {
		array	= try decoder.decode(for: Key.array )
		value	= try decoder.decode(for: Key.value )
	}
}

class AClass : GCodable {
	var astruct	= AStruct()
	var aclass	: AClass?
	
	private enum Key : String {
		case astruct, aclass
	}
	
	init() {}
	
	func encode(to encoder: some GEncoder) throws {
		try encoder.encode( astruct, for: Key.astruct )
		// note:
		try encoder.encodeConditional( aclass,  for: Key.aclass )
	}
	
	required init(from decoder: some GDecoder) throws {
		astruct	= try decoder.decode(for: Key.astruct )
		aclass	= try decoder.decode(for: Key.aclass )
	}
}

let a = AClass()
let b = AClass()

//	we store a in b.aclass while a.aclass remains nil
b.aclass	= a

let	inRoot = [b, b, b, b, a]

print( try GraphEncoder().dump( inRoot ) )
```
The result:

```
== BODY ==========================================================
- VAL
	- REF0001 MyGraphCodableApp.AClass
		+ "astruct": VAL
			+ "array": BIV [1, 2, 3]
			+ "value": BIV 1.56
		.
		+ "aclass": PTC0002
	.
	- PTS0001
	- PTS0001
	- PTS0001
	- REF0002 MyGraphCodableApp.AClass
		+ "astruct": VAL
			+ "array": BIV [1, 2, 3]
			+ "value": BIV 1.56
		.
		+ "aclass": NIL
	.
.
==================================================================
```
By default `dump()` prints only the **BODY** section of the data.

The **BODY** section contains the structured data, organized in:
- *Sequences*: a list of items preceded by the **-** symbol.
- *Dictionaries*: a list of items (in the form "key": value) preceded by the **+** symbol.

Both lists end when the symbol **.** is encountered.

The root is always the only item of the first sequence.

Rows by rows:
-	`VAL`, a value type, is the root.
-	It contains 5 elements corresponding to `[b, b, b, b, a]`:
	-	The first element `REF0001 MyGraphCodableApp.AClass` is a reference (`REF`) type.
		GraphCodable assigns a unique numeric `id` in `REF<id>` to each object it encounters.
		This object in turn contains a structure corresponding to the key 'astruct' and an object corresponding to the key 'aclass'
		-	First, you see the complete definition of the struct, with its array and its float value. They contain native types.
			The list of all GCodable supported types of Swift Standard Library and Foundation is [here](/Docs/GraphCodableTypes.md).
		- 	Then you see: `"aclass": PTC0002` This is because aclass has been conditionally archived.
			The encoder assigns it a **conditional** pointer (`PTC`) with a free `<id>` and waits for it to be stored unconditionally if it happens.
	-	The second, third and fourth element of the array are **strong** (`PTS`) pointers `PTS0001` to **b**, which has already been stored as `REF0001` (the `<id>` is the same).
	-	The fifth element `REF0002` is `a` which was only conditionally archived previously (`PTC0002`) and is therefore archived now.

What happens if you delete `a` from the `inRoot`array?  See here: `a` was only conditionally archived and so don't be archived.

```
== BODY ==========================================================
- VAL
	- REF0001 MyGraphCodableApp.AClass
		+ "astruct": VAL
			+ "array": BIV [1, 2, 3]
			+ "value": BIV 1.56
		.
		+ "aclass": PTC0002
	.
	- PTS0001
	- PTS0001
	- PTS0001
.
==================================================================
```

Now, if you encode `"aclass"` not-conditionally:

```swift
	func encode(to encoder: some GEncoder) throws {
		try encoder.encode( astruct, for: Key.astruct )
		try encoder.encode( aclass,  for: Key.aclass )
	}

```



this is the result:

```
== BODY ==========================================================
- VAL
	- REF0001 MyGraphCodableApp.AClass
		+ "astruct": VAL
			+ "array": BIV [1, 2, 3]
			+ "value": BIV 1.56
		.
		+ "aclass": REF0002 MyGraphCodableApp.AClass
			+ "astruct": VAL
				+ "array": BIV [1, 2, 3]
				+ "value": BIV 1.56
			.
			+ "aclass": NIL
		.
	.
	- PTS0001
	- PTS0001
	- PTS0001
.
==================================================================
```

## Binary like output of the encoded data

GraphCodable employs some tricks to reduce the size of the data to be stored.
For example, types and keys are saved only once in special tables and are addressed to them through a unique ID.
By using the '.binaryLike' option you can see the data saved in a format that more closely resembles the binary format actually used.
By using the '.showMangledClassNames' option it is possible to see the archived string which will be used to construct the type during dearchiving.
Graphcodable tries `_typeByName( MangledName )` first and then `NSClassFromString( NSTypeName )`

Try replacing:
`print( try GraphEncoder().dump( inRoot ) )`
with:
`print( try GraphEncoder().dump( inRoot, options: [.binaryLike,.showMangledClassNames] ) )`
in the previous code.

The result:
```
== HEADER ========================================================
FILETYPE = gcodable V4, U0 = 0, U1 = 0
== BODY ==========================================================
- VAL
	- REF0001 TYPE0001
		+ KEY0001: VAL
			+ KEY0002: BIV {32 bytes}
			+ KEY0003: BIV {8 bytes}
		.
		+ KEY0004: PTC0002
	.
	- PTS0001
	- PTS0001
	- PTS0001
	- REF0002 TYPE0001
		+ KEY0001: VAL
			+ KEY0002: BIV {32 bytes}
			+ KEY0003: BIV {8 bytes}
		.
		+ KEY0004: NIL
	.
.
== REFERENCEMAP ==================================================
TYPE0001:	MyGraphCodableApp.AClass V0
			MangledName = 17MyGraphCodableApp6AClassC
			NSTypeName  = MyGraphCodableApp.AClass
== KEYMAP ========================================================
KEY0002:	"array"
KEY0003:	"value"
KEY0001:	"astruct"
KEY0004:	"aclass"
==================================================================
```
You can see:
- The **HEADER** section, with the file format name (gcodable), its global version, and some unused fields;
- The **BODY** section, which uses typeIDs and keyIDs;
- The **REFERENCEMAP** section, in which an **TypeID** is associated with each class with its version;
- The **KEYMAP** section, in which an **KeyID** is associated with each key used in keyed coding.



