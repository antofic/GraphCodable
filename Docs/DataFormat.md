#  Data Format

GraphEncoder encode data in a private binary format. Having to preserve information about the types, GraphCodable creates larger data in bytes than those generated by Codable encoders. Despite this, the time required for encoding and decoding is generally comparable if not faster.

You can get a readable representation of the encoded data in a string with the `dump()` function.

## Readable output of the encoded data
Let's consider this example:
```swift
import Foundation
import GraphCodable

GTypesRepository.initialize()

struct AStruct : Equatable, GCodable {
	var array	= [1,2,3]
	var dict	= ["4":4,"5":5]
	
	init() {}
	
	private enum Key : String {
		case array, dict
	}
	
	func encode(to encoder: GEncoder) throws {
		try encoder.encode( array, for: Key.array )
		try encoder.encode( dict, for: Key.dict )
	}
	
	init(from decoder: GDecoder) throws {
		array	= try decoder.decode(for: Key.array )
		dict	= try decoder.decode(for: Key.dict )
	}
}

class AClass : GCodable {
	var astruct	= AStruct()
	var aclass	: AClass?
	
	private enum Key : String {
		case astruct, aclass
	}
	
	init() {}
	
	func encode(to encoder: GEncoder) throws {
		try encoder.encode( astruct, for: Key.astruct )
		// note:
		try encoder.encodeConditional( aclass,  for: Key.aclass )
	}
	
	required init(from decoder: GDecoder) throws {
		astruct	= try decoder.decode(for: Key.astruct )
		aclass	= try decoder.decode(for: Key.aclass )
	}
}

let a = AClass()
let b = AClass()

//	we store a in b.aclass while a.aclass remains nil
b.aclass	= a

let	inRoot = [b, b, b, b, a]

print( try GraphEncoder().dump( inRoot ) )
```
The result:

```
== HEADER ========================================================
Filetype = gcodable V0, * = MyGraphCodableApp, U1 = 0, U2 = 0
== GRAPH =========================================================
- STRUCT
	- CLASS *.AClass Obj1000
		+ "astruct": STRUCT
			+ "array": [1, 2, 3]
			+ "dict": ["4": 4, "5": 5]
		.
		+ "aclass": POINTER? Obj1001
	.
	- POINTER Obj1000
	- POINTER Obj1000
	- POINTER Obj1000
	- CLASS *.AClass Obj1001
		+ "astruct": STRUCT
			+ "array": [1, 2, 3]
			+ "dict": ["5": 5, "4": 4]
		.
		+ "aclass": nil
	.
.
==================================================================
```
 You can see:

The **HEADER**, with the file format name (gcodable), its version, a the placeholder ``* = MainModuleName`` and some unused fields.
The main module name purposely has no effect when unarchiving and for this reason is replaced by an asterisk in the following type definitions.
This way you can open the same file from an app with a different main module name.
GraphCodable does not currently allow access to the data contained in the header.

The **GRAPH** that contains the structured data, organized in:
- *Sequences*: a list of items preceded by the **-** symbol.
- *Dictionaries*: a list of items (in the form "key": value) preceded by the **+** symbol.

Both lists end when the symbol **.** is encountered.

The root is always the only item of the first sequence.

Rows by rows:
-	``STRUCT``, a value type, is the root.
-	It contains 5 elements corresponding to ``[b, b, b, b, a]``:
	-	The first element ``CLASS *.AClass Obj1000`` is a reference (``CLASS``) type.
		GraphCodable assigns a unique numeric ``ID (ObjXXXX)`` to each object it encounters.
		This object in turn contains a structure corresponding to the key 'astruct' and an object corresponding to the key 'aclass'
		-	First, you see the complete definition of the struct, with its array and its dictionary. They contain native types.
			-	GraphCodable treats the following types as "native" (knows how to save them):
				-	**Int**, **Int8**, **Int16**, **Int32**, **Int64**, **UInt**, **UInt8**, **UInt16**, **UInt32**, **UInt64**
				-	**Float**, **Double**
				-	**String**, **Data**
			-	In addition, GraphCodable conforms the following types to GCodable:
				-	**Array**, **Dictionary**, **Set**, **Optional**, **OptionSet**
				-	 any **enum** whose rawValue is a native type, except **Data**
		- 	Then you see: ``"aclass": POINTER? Obj1001`` This is because aclass has been conditionally archived.
			The encoder assigns it an attempt ``ID (POINTER?)`` and waits for it to be stored unconditionally if it happens.
	-	The second, third and fourth element of the array are always **b**, which has already been stored with ``ID=Obj1000``.
		Therefore the encoder only stores the ``ID``, which this time is certain (``POINTER``without question mark).
	-	The fifth element is ``a`` which was not archived previously and is therefore archived now.

*As an exercise*: see what happens when you delete ``a`` from the array.

*As an exercise*: try to see what happens by encoding ``"aclass"`` *not-conditionally*.

## Binary like output of the encoded data

GraphCodable employs some tricks to reduce the size of the data to be stored.
For example, types and keys are saved only once in special tables and are addressed to them through a unique ID.
By using the '.binaryLike' option you can see the data saved in a format that more closely resembles the binary format actually used.

`print( try GraphEncoder().dump( inRoot, dumpOptions: .binaryLike, encodeOptions: .fastest ) )`

```
== HEADER ========================================================
Filetype = gcodable V0, * = MyGraphCodableApp, U1 = 0, U2 = 0
== TYPEMAP =======================================================
Type100: V0 *.AClass
== GRAPH =========================================================
- STRUCT
	- CLASS Type100 Obj1000
		+ Key100: STRUCT
			+ Key101: [1, 2, 3]
			+ Key102: ["4": 4, "5": 5]
		.
		+ Key103: POINTER? Obj1001
	.
	- POINTER Obj1000
	- POINTER Obj1000
	- POINTER Obj1000
	- CLASS Type100 Obj1001
		+ Key100: STRUCT
			+ Key101: [1, 2, 3]
			+ Key102: ["4": 4, "5": 5]
		.
		+ Key103: nil
	.
.
== KEYMAP ========================================================
Key101: "array"
Key103: "aclass"
Key102: "dict"
Key100: "astruct"
==================================================================
```
We see how the **GRAPH** section uses IDs for types and keys, while the type and key strings are stored once in only two tables, one (**TYPEMAP**) preceding the **GRAPH** section and another (**KEYMAP**) following it. The version of the type (**V...**) is also stored in the type table.

We also see an optimization in action, by default during encoding but normally disabled during dump, capable of quickly collapsing any combination of arrays, dictionaries and sets containing ultimately native elements (including optionals) into a sequence of bytes (you can see **BINARY 64 bytes** replacing the "dict" dictionary) . Thanks to this optimization, encoding and decoding are faster and the size of the generated data reduced.


