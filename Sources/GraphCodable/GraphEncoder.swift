//	Apache License
//	Version 2.0, January 2004
//	http://www.apache.org/licenses/
//
//	Copyright (c) 2021-2023 Antonino Ficarra

import Foundation

typealias TheEncoder = GEncoderImpl

///	An object that encodes instances of a **GEncodable** type
///	into a data buffer that uses **GraphCodable** format.
public final class GraphEncoder {
	private let encoder	: TheEncoder

	/// GraphEncoder init method
	///
	/// - Parameter options: encoder user defined flags
	/// - Parameter userVersion: global user defined version of the archive
	/// - Parameter archiveIdentifier: a string identifier for the archive
	/// - Note: By default, the identifier `defaultGraphCodableArchiveIdentifier` is used.
	/// - Note: If you pass nil no identifiers will be encoded.
	public init(
		_ options: Options = .defaultOptions,
		userVersion: UInt32 = 0,
		archiveIdentifier: String? = defaultGraphCodableArchiveIdentifier
	) {
		encoder	= TheEncoder(
			options, userVersion:userVersion, archiveIdentifier: archiveIdentifier
		)
	}

	///	Get the archiveIdentifier
	public var archiveIdentifier: String? {
		encoder.archiveIdentifier
	}

	///	Get/Set the userInfo dictionary
	public var userInfo : [String:Any] {
		get { encoder.userInfo }
		set { encoder.userInfo = newValue }
	}

	///	Encode the root value in a native binary format buffer
	///
	///	Example:
	///	```
	///	let data = try GraphEncoder().encode( root ) as Data
	///	```
	/// or:
	///	```
	///	let data = try GraphEncoder().encode( root ) as Bytes
	///	```
	///
	/// - Parameter value: the archive root value to encode.
	/// - Returns: the encoded data in a native binary format.
	///	- Note: The root value must conform to the `GEncodable` protocol.
	///	- Note: You must specify buffer type (typically `Data` or `Bytes = [UInt8]`).
	public func encode<Q>( _ value: some GEncodable ) throws -> Q where Q:MutableDataProtocol {
		try encoder.encodeRoot( value )
	}
	
	///	Creates a human-readable string of the data that would be generated by encoding the value
	///
	/// Example:
	/// ```
	///	let string = try GraphEncoder().dump( root )
	/// ```
	///
	/// - Parameter value: the archive root value to encode.
	/// - Parameter options: a series of options to choose the information to be generated.
	/// - Returns: a human-readable string representation of the archive that would be generated.
	/// by the `encode(...)` function.
	///	- Note: The root value must conform to the `GEncodable` protocol.
	///	- Note: The generated string cannot be used for decoding.
	public func dump( _ value: some GEncodable, options: GraphDumpOptions = .readable ) throws -> String {
		try encoder.dumpRoot( value, options:options )
	}
}

// -------------------------------------------------
// ----- GraphEncoder.Options
// -------------------------------------------------

extension GraphEncoder {
	/// Options for GraphEncoder init method
	public struct Options: OptionSet {
		public let rawValue: UInt
		
		public init(rawValue: UInt) {
			self.rawValue	= rawValue
		}
		
		///	Select the mangling mode
		public static let	useNSClassFromStringMangling						= Self( rawValue: 1 << 0 )
		///	Disable compression
		///
		/// By default integers are compressed to produce smaller files.
		/// This option disables compression.
		///
		/// - Note: Compression is enabled by default
		public static let	disableCompression									= Self( rawValue: 1 << 1 )
		
		///	Disable moving encoded data
		///
		/// The encoder moves certain data during encoding to always allow integer
		/// compression (uses BinaryIOEncoder `insert(...)` function).
		/// This option prevents the encoder from moving the data and in some cases
		/// the compression will be less effective (uses BinaryIOEncoder
		/// `prepend(...)` function instead).
		///
		/// - Note: This option is disabled by default
		public static let	dontMoveEncodedData									= Self( rawValue: 1 << 2 )
		
		///	Disable identity
		///
		/// All types will be encoded with no identity regardless of how they are defined.
		///
		/// - Note: This option is disabled by default
		public static let	disableIdentity										= Self( rawValue: 1 << 3 )
		
		///	Disable inheritance
		///
		/// All reference types will be encoded with no class name info's.
		///
		/// - Note: This option is disabled by default
		public static let	disableInheritance									= Self( rawValue: 1 << 4 )

		///	Resort to hashable identity
		///
		/// If .disableIdentity == false, uses immediately the value as identity.
		///
		/// - Note: This option is disabled by default
		/// - Note: The option can be expensive in certain situations
		public static let	tryHashableIdentityAtFirst							= Self( rawValue: 1 << 5 )
		///	Resort to hashable identity if any other fails
		///
		/// If .disableIdentity == false, any other tentative to aquire an identity
		/// has failed, the value is Hashable, uses the value as identity.
		///
		/// - Note: This option is disabled by default
		/// - Note: The option can be expensive in certain situations
		public static let	tryHashableIdentityAtLast							= Self( rawValue: 1 << 6 )

		///	Enable printing of warnings
		///
		/// If this flag is enabled, the encoder doesn't generate an exception
		/// but print a warning if:
		/// - a value with no identity is conditionally encoded.
		/// The value is encoded unconditionally.
		/// - a reference type uses the versioning system. To use the versioning
		/// system, the reference type must have identity.
		///
		/// - Note: This option is auto-enabled if DEBUG is active.
		public static let	printWarnings										= Self( rawValue: 1 << 7 )

		public static let	mimicSwiftCodable:				Self 	= [ disableIdentity, disableInheritance ]
		public static let	defaultOptions:					Self 	= []
	}
}

