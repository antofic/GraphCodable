//	Apache License
//	Version 2.0, January 2004
//	http://www.apache.org/licenses/
//
//	Copyright (c) 2021-2023 Antonino Ficarra

import Foundation


///	An object that decodes instances of a **GDecodable** type
///	from a data buffer that uses **GraphCodable** format.
public final class GraphDecoder {
	private let decoder : GDecoderImpl

	/// GraphDecoder init method
	///
	/// - If `archiveIdentifier` is not `nil`, it must match the encoded one otherwise the
	/// `Errors.BinaryIOError.archiveIdentifierDontMatch` exception is thrown.
	/// - If `archiveIdentifier` is `nil`, any encoded archiveIdentifier match
	///
	/// - Parameter archiveIdentifier: a string identifier to match the encoded one
	/// - Note: By default, the identifier `defaultGraphCodableArchiveIdentifier` is used.
	public init( archiveIdentifier: String? = defaultGraphCodableArchiveIdentifier ) {
		self.decoder = GDecoderImpl( archiveIdentifier:archiveIdentifier )
	}
	
	///	get/set the userInfo dictionary
	public var userInfo : [String:Any] {
		get { decoder.userInfo }
		set { decoder.userInfo = newValue }
	}
	
	///	get the dictionary that maps the type to create
	///	when an encoded className is encountered
	public var classNameMap : ClassNameMap {
		decoder.classNameMap
	}
	
	///	Set the type to create when an encoded className
	///	is encountered.
	///
	///	**The type can also be a value type.**
	///
	/// - Parameter type: the type to create.
	/// - Parameter className: a struct that specifies the name of the encoded
	/// class to match the type to create
	public func setType( _ type:any GDecodable.Type, for className:ClassName ) {
		decoder.classNameMap[ className ] = type
	}
	
	///	Decode the root value from a native binary format buffer
	///
	/// Example:
	/// ```
	///	let root = try GraphDecoder().decode( RootType.self, from: data )
	/// ```
	///
	/// - Parameter type: the value type to decode.
	/// - Parameter data: the native binary format buffer.
	///	- Note: The root value must conform to the `GDecodable` protocol
	///	- Note: Only archives generated by `GraphEncoder` can be decoded
	public func decode<T>( _ type: T.Type, from data: some BinaryDataProtocol ) throws -> T
	where T:GDecodable {
		return try decoder.decodeRoot( type, from: data)
	}

	///	Creates a human-readable string of the archived data
	///
	/// Example:
	/// ```
	///	let string = try GraphDecoder().dump( from: data )
	/// ```
	///
	/// - Parameter data: the archived data to decode.
	/// - Parameter options: a series of options to choose the information to be generated.
	/// - Returns: a human-readable string representation of the archive that would be generated.
	/// by the `encode(...)` function.
	public func dump( from data: some BinaryDataProtocol, options: GraphDumpOptions = .readable ) throws -> String {
		try decoder.dumpRoot( from: data, options:options )
	}
	
	///	Check if the data to decode contains a cyclic graph.
	///
	/// If the data to decode contains a cyclic graph it is necessary to use
	/// `deferDecode` for the decoding.
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: `true` if the data to decode contains a cyclic graph, `false` otherwise.
	/// by the `encode(...)` function.
	public func isCyclic( from data: some BinaryDataProtocol ) throws -> Bool {
		try decoder.isCyclic(from: data)
	}

	///	Get the archiveIdentifier encoded in the archived data
	///
	/// Example:
	/// ```
	///	let identifier = try GraphDecoder().encodedArchiveIdentifier( from: data )
	/// ```
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: the encoded archiveIdentifier.
	/// - Note: the encoded archiveIdentifier can be `nil`
	public func encodedArchiveIdentifier( from data: some BinaryDataProtocol ) throws -> String? {
		try decoder.encodedArchiveIdentifier(from: data )
	}

	///	Returns an array of types that will potentially be instantiated
	///	after replacements from encoded classes  in the data byte buffer
	///
	///	As a result of the replacements, types may not be classes
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: the requested array of `GDecodable` types.
	public func decodableTypes( from data: some BinaryDataProtocol ) throws -> [any GDecodable.Type] {
		return try decoder.allEncodedClass( from: data ).compactMap { $0.decodedType }
	}

	///	Returns all replaced classes encoded in the data byte buffer
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: the requested array of `GDecodable` types.
	public func replacedClasses( from data: some BinaryDataProtocol ) throws -> [any GDecodable.Type] {
		return try decoder.allEncodedClass( from: data ).compactMap { $0.replacedClass }
	}

	///	Returns a `ClassInfo` value for every undecodable class in the data byte buffer
	///
	/// - Parameter data: the archived data to decode.
	/// - Returns: the requested array of `ClassInfo` values.
	public func undecodableClasses( from data: some BinaryDataProtocol ) throws -> [ClassInfo] {
		return try decoder.allEncodedClass( from: data ).compactMap {
			$0.decodedType == nil ?
			$0.info : nil
		}
	}
}


